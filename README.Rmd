---
title: "Advent of Code 2020"
output: 
    github_document: 
        toc: true
        toc_depth: 1
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
walk(list.files(here::here("R"), full.names = TRUE), source)
```

Here's the work on Advent of Code 2020. Let's see if I do more than my usual thing of getting halfway and then not finding time for the rest!

# Day 1

## Part 1

First we need the product of the two numbers in the expense report that add to 2020. 

```{r day01-part1}
day01_expense_report <- readLines(here::here("data/day01.txt")) %>% 
    as.double()

day01_expense_report %>% 
    {
        expand_grid(
            num1 = ., 
            num2 = .
        )
    } %>% 
    filter(
        # Get rid of rows where a number is paired with itself, and dedupe, by 
        # requiring that num1 < num2
        num1 < num2, 
        # Keep just the row with the right sum
        near(num1 + num2, 2020)
    ) %>% 
    pivot_longer(cols = everything()) %>% 
    pull(value) %>% 
    reduce(`*`) %>% 
    {
        sprintf("Part 1 answer is %s", .)
    }
```

## Part 2

Now do the same but for the **three** numbers that add to 2020. 

```{r day01-part2}
day01_expense_report %>% 
    {
        expand_grid(
            num1 = ., 
            num2 = ., 
            num3 = .
        )
    } %>% 
    filter(
        # Get rid of rows where a number is paired with itself, and dedupe, by 
        # requiring that num1 < num2
        num1 < num2, 
        num2 < num3, 
        # Keep just the row with the right sum
        near(num1 + num2 + num3, 2020)
    ) %>% 
    pivot_longer(cols = everything()) %>% 
    pull(value) %>% 
    reduce(`*`) %>% 
    {
        sprintf("Part 2 answer is %s", .)
    }
```

# Day 2

## Part 1

Count how many of the passwords are valid. Created a function to compare a password and policy and test if it's valid. 

```{r test_password}
test_password
```

```{r day02-part1}
day02_passwords <- read_delim(
    here::here("data/day02.txt"), 
    delim = " ", 
    col_names = c("policy", "letter", "password"), 
    col_types = "ccc"
) %>% 
    # get rid of the trailing colon on the letter
    mutate(
        letter = str_remove(letter, ":")
    )
day02_passwords %>% 
    mutate(valid = pmap_lgl(., test_password)) %>% 
    filter(valid) %>% 
    {
        sprintf("Part 1 answer is %s", nrow(.))
    }
```

## Part 2

Now we need a different version of the password testing function that will comply with the Official Toboggan Corporate Policy (OTCP). 

```{r test_password_OTCP}
test_password_OTCP
```

```{r day02-part2}
day02_passwords %>% 
    mutate(valid = pmap_lgl(., test_password_OTCP)) %>% 
    filter(valid) %>% 
    {
        sprintf("Part 2 answer is %s", nrow(.))
    }
```

# Day 3

## Part 1

Need to navigate the map and count the number of trees we hit travelling **down 1, across 3** at every step. The same map repeats infinitely to the right. 

```{r day03-data}
# Save the 'raw' input: partly because its dimensions will be useful when
# creating the map, partly because I'm bound to need it again for Part 2
day03_input <- readLines(here::here("data/day03.txt"))

day03_map <- day03_input %>% 
    map(
        ~ .x %>% 
            str_split("") %>% 
            pluck(1)
    ) %>% 
    unlist() %>% 
    matrix(nrow = length(day03_input), byrow = TRUE)
```


```{r count_trees}
count_trees <- function(map_matrix, step_down, step_right) {
    
    # Easier to get the indices we will need separately
    rows <- seq(1, nrow(map_matrix), by = step_down)
    columns <- 
        seq(1, by = step_right, length.out = length(rows)) %% ncol(map_matrix)
    # Replacing the zeroes is maybe a bit hacky but this is the price we pay for
    # indexing from 1 and being unwilling to spend time on figuring out a more
    # elegant solution with modular arithmetic
    columns[columns == 0L] <- ncol(day03_map)
    
    map2_chr(rows, columns, ~ map_matrix[.x, .y]) %>% 
        str_c(collapse = "") %>% 
        str_count("#")
}
```


```{r day03-part1}
sprintf("Part 1 answer is %s trees", count_trees(day03_map, 1, 3))
```

## Part 2

Now need to check a number of trajectories and then return the product of the result. 

```{r day03-part2}
down <-  c(1, 1, 1, 1, 2)
right <- c(1, 3, 5, 7, 1)

map2_int(
    down, 
    right, 
    ~ count_trees(day03_map, .x, .y)
) %>% 
    prod() %>% 
    {
        sprintf("Part 2 answer is %s", .)
    }
```
