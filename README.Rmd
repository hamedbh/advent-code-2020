---
title: "Advent of Code 2020"
output: 
    github_document: 
        toc: true
        toc_depth: 1
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(igraph)
walk(list.files(here::here("R"), full.names = TRUE), source)
```

Here's my work on Advent of Code 2020. Let's see if I do more than my usual thing of getting halfway and then not finding time for the rest!

# Day 1

## Part 1

First we need the product of the two numbers in the expense report that add to 2020. 

```{r day1-part1}
day1_expense_report <- readLines(here::here("data/day1.txt")) %>% 
    as.double()

day1_expense_report %>% 
    {
        expand_grid(
            num1 = ., 
            num2 = .
        )
    } %>% 
    filter(
        # Get rid of rows where a number is paired with itself, and dedupe, by 
        # requiring that num1 < num2
        num1 < num2, 
        # Keep just the row with the right sum
        near(num1 + num2, 2020)
    ) %>% 
    pivot_longer(cols = everything()) %>% 
    pull(value) %>% 
    prod() %>% 
    {
        sprintf("Part 1 answer is %s", .)
    }
```

## Part 2

Now do the same but for the **three** numbers that add to 2020. 

```{r day1-part2}
day1_expense_report %>% 
    {
        expand_grid(
            num1 = ., 
            num2 = ., 
            num3 = .
        )
    } %>% 
    filter(
        # Get rid of rows where a number is paired with itself, and dedupe, by 
        # requiring that num1 < num2
        num1 < num2, 
        num2 < num3, 
        # Keep just the row with the right sum
        near(num1 + num2 + num3, 2020)
    ) %>% 
    pivot_longer(cols = everything()) %>% 
    pull(value) %>% 
    reduce(`*`) %>% 
    {
        sprintf("Part 2 answer is %s", .)
    }
```

# Day 2

## Part 1

Count how many of the passwords are valid. Created a function to compare a password and policy and test if it's valid. 

```{r test_password}
test_password
```

```{r day2-part1}
day2_passwords <- read_delim(
    here::here("data/day2.txt"), 
    delim = " ", 
    col_names = c("policy", "letter", "password"), 
    col_types = "ccc"
) %>% 
    # get rid of the trailing colon on the letter
    mutate(
        letter = str_remove(letter, ":")
    )
day2_passwords %>% 
    mutate(valid = pmap_lgl(., test_password)) %>% 
    filter(valid) %>% 
    {
        sprintf("Part 1 answer is %s", nrow(.))
    }
```

## Part 2

Now we need a different version of the password testing function that will comply with the Official Toboggan Corporate Policy (OTCP). 

```{r test_password_OTCP}
test_password_OTCP
```

```{r day2-part2}
day2_passwords %>% 
    mutate(valid = pmap_lgl(., test_password_OTCP)) %>% 
    filter(valid) %>% 
    {
        sprintf("Part 2 answer is %s", nrow(.))
    }
```

# Day 3

## Part 1

Need to navigate the map and count the number of trees we hit travelling **down 1, across 3** at every step. The same map repeats infinitely to the right. 

```{r day3-data}
# Save the 'raw' input: partly because its dimensions will be useful when
# creating the map, partly because I'm bound to need it again for Part 2
day3_input <- readLines(here::here("data/day3.txt"))

day3_map <- day3_input %>% 
    map(
        ~ .x %>% 
            str_split("") %>% 
            pluck(1)
    ) %>% 
    unlist() %>% 
    matrix(nrow = length(day3_input), byrow = TRUE)
```


```{r count_trees}
count_trees
```

```{r day3-part1}
sprintf("Part 1 answer is %s trees", count_trees(day3_map, 1, 3))
```

## Part 2

Now need to check a number of trajectories and then return the product of the result. 

```{r day3-part2}
down <-  c(1, 1, 1, 1, 2)
right <- c(1, 3, 5, 7, 1)

map2_int(
    down, 
    right, 
    ~ count_trees(day3_map, .x, .y)
) %>% 
    prod() %>% 
    {
        sprintf("Part 2 answer is %s", .)
    }
```
# Day 4

## Part 1

Data validation. This is a bit of a busman's holiday but off we go. 

```{r day4-setup}
# get the required fields
req <- c("byr", "iyr", "eyr", "hgt", "hcl", "ecl", "pid")
day4_input <- tibble(x = read_lines(here::here("data/day4.txt")))

day4_passports <- day4_input %>% 
    mutate(id = cumsum(x == "")) %>% 
    mutate(pairs = str_match_all(x, "(...)\\:([^ ]+)")) %>% 
    mutate(
        key = map(pairs, ~ .x[, 2]), 
        value = map(pairs, ~ .x[, 3])
    ) %>% 
    select(-c(x, pairs)) %>% 
    unnest(c(key, value))
```

Now we have the passports cleaned up it's just grouping and counting. 

```{r day4-part1}
day4_valid <- day4_passports %>% 
    group_by(id) %>% 
    filter(all(req %in% c(key)))

sprintf("Part 1 answer is %s valid passports", 
        length(unique(day4_valid$id)))
```

## Part 2

Now need to validate the values. 

```{r day4-part2}
day4_valid %>% 
    # make sure we don't have any stray spaces messing things up in the value 
    # field
    mutate(across(where(is.character), str_trim)) %>% 
    pivot_wider(names_from = "key") %>% 
    # now filter the records
    filter(
        between(as.integer(byr), 1920L, 2002L),
        between(as.integer(iyr), 2010L, 2020L), 
        between(as.integer(eyr), 2020L, 2030L),
        
        (str_detect(hgt, "cm") & between(parse_number(hgt), 150, 193)) | 
            (str_detect(hgt, "in") & between(parse_number(hgt), 59, 76)), 
        
        str_detect(hcl, "^\\#[a-f0-9]{6}$"), 
        
        ecl %in% c("amb", "blu", "brn", "gry", "grn", "hzl", "oth"), 
        
        str_detect(pid, "^\\d{9}$")
    ) %>% 
    pull(id) %>% 
    length() %>% 
    {
        sprintf("Part 2 answer is %s", .)
    }
```

# Day 5

## Part 1

The problem uses binary partitioning to find a seat on the plane. The row numbers get higher as they go from the `F`ront to the `B`ack; column numbers start low on the `L`eft and are higher on the `R`ight. 

Can do this by converting to binary. 

```{r parse_seat_spec}
parse_seat_spec
```

Now point this at today's input. 

```{r day5-part1}
day5_specs <- tibble(seat_spec = read_lines(here::here("data/day5.txt")))

day5_seats <- day5_specs %>% 
    mutate(combined = map(seat_spec, parse_seat_spec)) %>% 
    unnest_wider(combined) %>% 
    mutate(seat_id = map2_int(row, col, ~ (8L * .x) + .y))

sprintf("Part 1 answer: highest seat ID is %s", max(day5_seats$seat_id))
```

## Part 2

Need to find my seat, which is the only one missing. I know that mine won't be the lowest or highest seat ID.

```{r day5-part2}
seq(min(day5_seats$seat_id), max(day5_seats$seat_id)) %>% 
    setdiff(day5_seats$seat_id) %>% 
    {
        sprintf("Part 2 answer: my seat id is %s", .)
    }
```

# Day 6

## Part 1

Need counts for how many distinct questions were answered yes by anyone in each group. Or: the union of all the sets of answers. 

```{r day6-part1}
day6_answers <- tibble(x = read_lines(here::here("data/day6.txt"))) %>% 
    mutate(group_id = cumsum(x == "")) %>% 
    filter(x != "") %>% 
    add_count(group_id, name = "group_size") %>% 
    mutate(split_x = str_split(x, ""))

day6_answers %>% 
    group_by(group_id) %>% 
    summarise(all_yes = reduce(split_x, union), .groups = "drop") %>% 
    nrow() %>% 
    {
        sprintf("Part 1 answer is %s", .)
    }
```

## Part 2

Now need counts for how many questions were answered yes by _everyone_ in each group. Just replace `union()` with `intersect()`. 

```{r}
day6_answers %>% 
    group_by(group_id) %>% 
    summarise(all_yes = reduce(split_x, intersect), .groups = "drop") %>% 
    nrow() %>% 
    {
        sprintf("Part 2 answer is %s", .)
    }
```

# Day 7

## Part 1

```{r day7-part1}
day7_input <- read_lines(here::here("data/day7.txt"))
day7_tidy <- tibble(x = day7_input) %>%
    separate(x, into = c("outside", "inside"), sep = " contain ") %>% 
    separate_rows(inside, sep = ", ") %>% 
    filter(!(str_detect(inside, "no other bag"))) %>% 
    mutate(inside_bag_count = parse_number(inside)) %>% 
    mutate(
        outside = str_match(outside, "([a-z]+ [a-z]+) bag")[, 2], 
        inside  = str_match(inside, "^\\d+ ([a-z]+ [a-z]+) bag")[, 2]
    )

day7_tidy %>% 
    select(from = inside, to = outside) %>% 
    graph_from_data_frame() %>% 
    all_simple_paths(
        from = "shiny gold", 
        mode = "out"
    ) %>% 
    map(~ attr(.x, "names") %>% str_subset("shiny gold", negate = TRUE)) %>% 
    unlist() %>% 
    unique() %>% 
    length() %>% 
    {
        sprintf("There are %s possible containers", .)
    }
```

## Part 2

Now we need to count the total number of bags that the `shiny gold` must contain. Use some recursion for this. Took me a while to get it right, forgot to add the 1 at the end. 

```{r day7-part2}
count_bags <- function(bag_desc) {
    d <- day7_tidy %>% 
        filter(outside == bag_desc)
    
    sum(
        d$inside_bag_count * 
            (map_dbl(d$inside, count_bags) + 1)
    )
}

sprintf(
    "Part 2 answer: the shiny gold bag must contain %s other bags", 
    count_bags("shiny gold")
)
```
